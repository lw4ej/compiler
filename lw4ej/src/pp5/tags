ArgMismatch	errors.cc	/^void ReportError::ArgMismatch(Expr *arg, int argIn/
Assert	utility.h	/^#define Assert(expr)  \\$/
BeginFunc	tac.cc	/^BeginFunc::BeginFunc() {$/
BracketsOnNonArray	errors.cc	/^void ReportError::BracketsOnNonArray(Expr *baseExp/
BreakOutsideLoop	errors.cc	/^void ReportError::BreakOutsideLoop(BreakStmt *bStm/
BuiltIn	codegen.h	/^               PrintInt, PrintString, PrintBool, H/
Case	ast_stmt.cc	/^Case::Case(IntConstant *v, List<Stmt*> *s) {$/
Check	ast_decl.cc	/^void VarDecl::Check() {$/
CheckImp	ast_decl.cc	/^void ClassDecl::CheckImp()$/
CodeGenerator	codegen.cc	/^CodeGenerator::CodeGenerator()$/
CompareArguments	ast_expr.cc	/^bool Call::CompareArguments(List<VarDecl*> *formal/
CompareFnDecls	ast_decl.cc	/^bool FnDecl::CompareFnDecls( FnDecl* b)$/
ConditionalStmt	ast_stmt.cc	/^ConditionalStmt::ConditionalStmt(Expr *t, Stmt *b)/
ConsTable	ast_decl.cc	/^SymbolTable* ClassDecl::ConsTable(){$/
Decl	ast_decl.cc	/^VarDecl::VarDecl(Identifier *n, Type *t) : Decl(n)/
DeclConflict	errors.cc	/^void ReportError::DeclConflict(Decl *decl, Decl *p/
DeclList	parser.y	/^DeclList  :            { \/* replace with your par/
DisplayTable	symboltable.cc	/^void SymbolTable::DisplayTable()$/
DoFinalCodeGen	codegen.cc	/^void CodeGenerator::DoFinalCodeGen()$/
Emit	ast_stmt.cc	/^void Program::Emit() {$/
EmitACall	mips.cc	/^void Mips::EmitACall(Location *dst, Location *fn)$/
EmitBeginFunction	mips.cc	/^void Mips::EmitBeginFunction(int stackFrameSize)$/
EmitBinaryOp	mips.cc	/^void Mips::EmitBinaryOp(BinaryOp::OpCode code, Loc/
EmitCallInstr	mips.cc	/^void Mips::EmitCallInstr(Location *result, const c/
EmitCopy	mips.cc	/^void Mips::EmitCopy(Location *dst, Location *src)$/
EmitEndFunction	mips.cc	/^void Mips::EmitEndFunction()$/
EmitGoto	mips.cc	/^void Mips::EmitGoto(const char *label)$/
EmitIfZ	mips.cc	/^void Mips::EmitIfZ(Location *test, const char *lab/
EmitLCall	mips.cc	/^void Mips::EmitLCall(Location *dst, const char *la/
EmitLabel	mips.cc	/^void Mips::EmitLabel(const char *label)$/
EmitLoad	mips.cc	/^void Mips::EmitLoad(Location *dst, Location *refer/
EmitLoadConstant	mips.cc	/^void Mips::EmitLoadConstant(Location *dst, int val/
EmitLoadLabel	mips.cc	/^void Mips::EmitLoadLabel(Location *dst, const char/
EmitLoadStringConstant	mips.cc	/^void Mips::EmitLoadStringConstant(Location *dst, c/
EmitParam	mips.cc	/^void Mips::EmitParam(Location *arg)$/
EmitPopParams	mips.cc	/^void Mips::EmitPopParams(int bytes)$/
EmitPreamble	mips.cc	/^void Mips::EmitPreamble()$/
EmitReturn	mips.cc	/^ void Mips::EmitReturn(Location *returnVal)$/
EmitSpecific	tac.cc	/^void LoadConstant::EmitSpecific(Mips *mips) {$/
EmitStore	mips.cc	/^void Mips::EmitStore(Location *reference, Location/
EmitVTable	mips.cc	/^void Mips::EmitVTable(const char *label, List<cons/
Enter	hashtable.cc	/^template <class Value> void Hashtable<Value>::Ente/
Expr	ast_expr.cc	/^IntConstant::IntConstant(yyltype loc, int val) : E/
ExprType	ast_expr.cc	/^Type* AssignExpr::ExprType(){$/
Failure	utility.cc	/^void Failure(const char *format, ...)$/
FieldNotFoundInBase	errors.cc	/^void ReportError::FieldNotFoundInBase(Identifier */
FillRegister	mips.cc	/^void Mips::FillRegister(Location *src, Register re/
FindClass	ast_expr.cc	/^ClassDecl* Expr:: FindClass(){$/
Formatted	errors.cc	/^void ReportError::Formatted(yyltype *loc, const ch/
GenACall	codegen.cc	/^Location *CodeGenerator::GenACall(Location *fnAddr/
GenAssign	codegen.cc	/^void CodeGenerator::GenAssign(Location *dst, Locat/
GenBeginFunc	codegen.cc	/^BeginFunc *CodeGenerator::GenBeginFunc()$/
GenBinaryOp	codegen.cc	/^Location *CodeGenerator::GenBinaryOp(const char *o/
GenBuiltInCall	codegen.cc	/^Location *CodeGenerator::GenBuiltInCall(BuiltIn bn/
GenEndFunc	codegen.cc	/^void CodeGenerator::GenEndFunc()$/
GenGoto	codegen.cc	/^void CodeGenerator::GenGoto(const char *label)$/
GenIfZ	codegen.cc	/^void CodeGenerator::GenIfZ(Location *test, const c/
GenLCall	codegen.cc	/^Location *CodeGenerator::GenLCall(const char *labe/
GenLabel	codegen.cc	/^void CodeGenerator::GenLabel(const char *label)$/
GenLoad	codegen.cc	/^Location *CodeGenerator::GenLoad(Location *ref, in/
GenLoadConstant	codegen.cc	/^Location *CodeGenerator::GenLoadConstant(int value/
GenLoadLabel	codegen.cc	/^Location *CodeGenerator::GenLoadLabel(const char */
GenPopParams	codegen.cc	/^void CodeGenerator::GenPopParams(int numBytesOfPar/
GenPushParam	codegen.cc	/^void CodeGenerator::GenPushParam(Location *param)$/
GenReturn	codegen.cc	/^void CodeGenerator::GenReturn(Location *val)$/
GenStore	codegen.cc	/^void CodeGenerator::GenStore(Location *dst,Locatio/
GenTempVar	codegen.cc	/^Location *CodeGenerator::GenTempVar()$/
GenVTable	codegen.cc	/^void CodeGenerator::GenVTable(const char *classNam/
GetIterator	hashtable.cc	/^template <class Value> Iterator<Value> Hashtable<V/
GetNextValue	hashtable.cc	/^template <class Value> Value Iterator<Value>::GetN/
IdentifierNotDeclared	errors.cc	/^void ReportError::IdentifierNotDeclared(Identifier/
InaccessibleField	errors.cc	/^void ReportError::InaccessibleField(Identifier *fi/
IncompatibleOperand	errors.cc	/^void ReportError::IncompatibleOperand(Operator *op/
IncompatibleOperands	errors.cc	/^void ReportError::IncompatibleOperands(Operator *o/
IndexOf	utility.cc	/^int IndexOf(const char *key)$/
InitParser	parser.y	/^void InitParser()$/
Insert	symboltable.cc	/^void SymbolTable::Insert(Decl* d){$/
Instruction	tac.cc	/^EndFunc::EndFunc() : Instruction() {$/
InterfaceNotImplemented	errors.cc	/^void ReportError::InterfaceNotImplemented(Decl *cd/
InvalidDirective	errors.cc	/^void ReportError::InvalidDirective(int linenum) {$/
IsArithType	ast_type.cc	/^bool Type::IsArithType(){$/
IsClassType	ast_type.cc	/^bool NamedType::IsClassType(){$/
IsCompatTo	ast_type.cc	/^bool Type::IsCompatTo(Type *other){$/
IsDebugOn	utility.cc	/^bool IsDebugOn(const char *key)$/
IsEquivalentTo	ast_type.cc	/^bool NamedType::IsEquivalentTo(Type *other) { $/
IsIntfType	ast_type.cc	/^bool NamedType::IsIntfType(){$/
Join	location.h	/^inline yyltype Join(yyltype first, yyltype last)$/
LValue	ast_expr.cc	/^ArrayAccess::ArrayAccess(yyltype loc, Expr *b, Exp/
LocationsAreSame	mips.cc	/^static bool LocationsAreSame(Location *var1, Locat/
LongIdentifier	errors.cc	/^void ReportError::LongIdentifier(yyltype *loc, con/
Lookup	ast.cc	/^Decl* Node::Lookup(Identifier * id, bool local){$/
LoopStmt	ast_stmt.cc	/^ForStmt::ForStmt(Expr *i, Expr *t, Expr *s, Stmt */
Mips	mips.cc	/^Mips::Mips() {$/
Mmain.cc	main.cc	/^int main(int argc, char *argv[])$/
NameForTac	mips.cc	/^const char *Mips::NameForTac(BinaryOp::OpCode code/
NewArraySizeNotInteger	errors.cc	/^void ReportError::NewArraySizeNotInteger(Expr *siz/
NewLabel	codegen.cc	/^char *CodeGenerator::NewLabel()$/
NoMainFound	errors.cc	/^void ReportError::NoMainFound() {$/
Node	ast.cc	/^Node::Node(yyltype loc) {$/
NumArgsMismatch	errors.cc	/^void ReportError::NumArgsMismatch(Identifier *fnId/
NumEntries	hashtable.cc	/^template <class Value> int Hashtable<Value>::NumEn/
OpCode	tac.h	/^    typedef enum {Add, Sub, Mul, Div, Mod, Eq, Les/
OpCodeForName	tac.cc	/^BinaryOp::OpCode BinaryOp::OpCodeForName(const cha/
OutputError	errors.cc	/^void ReportError::OutputError(yyltype *loc, string/
OverrideMismatch	errors.cc	/^void ReportError::OverrideMismatch(Decl *fnDecl) {/
ParseCommandLine	utility.cc	/^void ParseCommandLine(int argc, char *argv[])$/
Print	tac.cc	/^void Instruction::Print() {$/
PrintArgMismatch	errors.cc	/^void ReportError::PrintArgMismatch(Expr *arg, int /
PrintDebug	utility.cc	/^void PrintDebug(const char *key, const char *forma/
PrintStmt	ast_stmt.cc	/^PrintStmt::PrintStmt(List<Expr*> *a) {    $/
Program	ast_stmt.cc	/^Program::Program(List<Decl*> *d) {$/
Reason	mips.h	/^    typedef enum { ForRead, ForWrite } Reason;$/
RegContents	mips.h	/^    struct RegContents {$/
Register	mips.h	/^			t8, t9, k0, k1, gp, sp, fp, ra, NumRegs } Regis/
Remove	hashtable.cc	/^template <class Value> void Hashtable<Value>::Remo/
ReturnMismatch	errors.cc	/^void ReportError::ReturnMismatch(ReturnStmt *rStmt/
SearchGlobalFn	ast_expr.cc	/^Type* Call::SearchGlobalFn(){$/
SearchGlobalId	ast_expr.cc	/^Type* FieldAccess::SearchGlobalId(){$/
Segment	tac.h	/^typedef enum {fpRelative, gpRelative} Segment;$/
SetDebugForKey	utility.cc	/^void SetDebugForKey(const char *key, bool value)$/
SetFrameSize	tac.cc	/^void BeginFunc::SetFrameSize(int numBytesForAllLoc/
SetFunctionBody	ast_decl.cc	/^void FnDecl::SetFunctionBody(Stmt *b) { $/
SpillRegister	mips.cc	/^void Mips::SpillRegister(Location *dst, Register r/
Stmt	ast_stmt.cc	/^ReturnStmt::ReturnStmt(yyltype loc, Expr *e) : Stm/
StmtBlock	ast_stmt.cc	/^StmtBlock::StmtBlock(List<VarDecl*> *d, List<Stmt*/
SubscriptNotInteger	errors.cc	/^void ReportError::SubscriptNotInteger(Expr *subscr/
SwitchStmt	ast_stmt.cc	/^SwitchStmt::SwitchStmt(Expr *e, List<Case*> *c) {$/
TestNotBoolean	errors.cc	/^void ReportError::TestNotBoolean(Expr *expr) {$/
ThisOutsideClassScope	errors.cc	/^void ReportError::ThisOutsideClassScope(This *th) /
Type	ast_type.cc	/^Type::Type(const char *n) {$/
UnderlineErrorInLine	errors.cc	/^void ReportError::UnderlineErrorInLine(const char /
UnrecogChar	errors.cc	/^void ReportError::UnrecogChar(yyltype *loc, char c/
UntermComment	errors.cc	/^void ReportError::UntermComment() {$/
UntermString	errors.cc	/^void ReportError::UntermString(yyltype *loc, const/
_builtin	codegen.cc	/^static struct _builtin {$/
appendTable	symboltable.cc	/^void SymbolTable::appendTable(SymbolTable* ex)$/
base	tac.cc	/^  variableName(strdup(name)), segment(s), offset(o/
dst	tac.cc	/^  : dst(d) {$/
label	tac.cc	/^  : dst(d), label(strdup(l)) {$/
ltstr	hashtable.h	/^struct ltstr {$/
methodAddr	tac.cc	/^  : dst(d), methodAddr(ma) {$/
numBytes	tac.cc	/^  :  numBytes(nb) {$/
offset	tac.cc	/^  : dst(d), src(s), offset(off) {$/
op2	tac.cc	/^  : code(c), dst(d), op1(o1), op2(o2) {$/
param	tac.cc	/^  :  param(p) {$/
reasonT	errors.h	/^typedef enum {LookingForType, LookingForClass, Loo/
src	tac.cc	/^  : dst(d), src(s) {$/
val	tac.cc	/^  : dst(d), val(v) {$/
yyerror	errors.cc	/^void yyerror(const char *msg) {$/
yylex	scanner.l	/^%%$/
yyltype	location.h	/^} yyltype;$/
yyparse	parser.y	/^%%$/
